## Assignment 5
### Software Tools and Technologies
    Name : Ravish Ranjan
    Course : MCA
    Semester : 1st semester

### Objective
    Debug, log, and measure performance of a bash script.
---
### Step 1: Create a Sample Script
1. Create a script named process_data.sh:
```bash
touch proqcess_data.sh
```
```bash
cat process_data.sh
```
```bash
#!/bin/bash

INPUT_DIR="./data"
OUTPUT_FILE="./summary.txt"

echo "Processing files in $INPUT_DIR..."
> "$OUTPUT_FILE"

for file in "$INPUT_DIR"/*.txt; do
        echo "Processing $file"
        lines=$( cat "$file" | wc -l )
        words=$( cat "$file" | wc -w )
        chars=$( cat "$file" | wc -c )
        echo "$file : $lines lines, $words words, $chars characters" >> "$OUTPUT_FILE"
done

echo "All files processed"
```
---
### Step 2: Debuging the bash file
1. Debugging whole file
```bash
bash -x process_data . sh
```
---
2. Debugging only the loop
```bash
#!/bin/bash

INPUT_DIR="./data"
OUTPUT_FILE="./summary.txt"

echo "Processing files in $INPUT_DIR..."
> "$OUTPUT_FILE"

set -x
for file in "$INPUT_DIR"/*.txt; do
        echo "Processing $file"
        lines=$( cat "$file" | wc -l )
        words=$( cat "$file" | wc -w )
        chars=$( cat "$file" | wc -c )
        echo "$file : $lines lines, $words words, $chars characters" >> "$OUTPUT_FILE"
done
set +x

echo "All files processed"
```
```bash
bash -xv process_data.sh
```
---
### Step 3: Add Logging and Error Handling
```bash
#!/bin/bash

LOGFILE="run.log"
ERRORLOG="error.log"
exec > >(tee -a "$LOGFILE" ) 2> >(tee -a "$ERRORLOG" >&2)
echo "$( date ) : Script started "

INPUT_DIR="./data"
OUTPUT_FILE="./summary.txt"

if [ ! -d "$INPUT_DIR" ]; then
        echo "$( date ) : ERROR - Input directory not found : $INPUT_DIR " >&2
        exit 1
fi
> "$OUTPUT_FILE"

echo "Processing files in $INPUT_DIR..."
> "$OUTPUT_FILE"

for file in "$INPUT_DIR"/*.txt; do
        if [ ! -f "$file" ]; then
                echo "$( date ) : WARNING - No file found" >&2
                continue
        fi
        echo "Processing $file"
        lines=$( cat "$file" | wc -l )
        words=$( cat "$file" | wc -w )
        chars=$( cat "$file" | wc -c )
        echo "$file : $lines lines, $words words, $chars characters" >> "$OUTPUT_FILE"
done

echo "$( date ) : Script completed successfully"
```
```bash
./process_data.sh
cat summary.txt
```
---
### Step 4: Measure Runtime and Performance
1. Measure execution time
```bash
time ./process_data.sh
```
---
2. Profile system performance
```bash
perf stat ./process_data.sh
```
---
3. Strace Command
```bash
strace -e open,read,write ./process_data.sh
```
---
4. CPU observation
```bash
top
```
---

### Step 5: Report Findings (10 mins)
1. Write a short report (5–10 lines) answering:
    - What debugging method helped you find issues?
    >
        During this debugging exercise, careful inspection of Bash syntax and variable usage helped identify issues, such as extra spaces inside quotes that caused directory-not-found errors.
    - How did logging improve script visibility?
    >
        Using logging with tee significantly improved script visibility, allowing both standard output and error messages to be captured in run.log and error.log, making it easier to trace execution flow and errors.
    - Which performance tool gave the most useful insights?
    >
        For performance analysis, time and strace -c were the most useful tools under WSL, since perf could not fully access hardware counters. These tools revealed that most of the script’s runtime is spent on file I/O operations rather than CPU-bound computations.
    - What would you optimize in the script?
    >
        the script could be improved by avoiding repeated calls to cat and wc, and instead using built-in Bash redirections or a single read loop, which would reduce unnecessary process spawning and improve efficiency. Additionally, trimming and formatting lines more efficiently could make the script faster on larger datasets.

